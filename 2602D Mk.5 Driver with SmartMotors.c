#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    pincherDegreeR, sensorPotentiometer)
#pragma config(Sensor, in2,    pincherDegreeL, sensorPotentiometer)
#pragma config(Sensor, in3,    battery2,       sensorAnalog)
#pragma config(Sensor, dgtl7,  encoderArm,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  encoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encoderR,       sensorQuadEncoder)
#pragma config(Motor,  port2,           pincherR,      tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           pincherL,      tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           armR1,         tmotorVex393_MC29, openLoop, driveRight, encoderPort, dgtl7)
#pragma config(Motor,  port5,           armR2,         tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           armL1,         tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port7,           armL2,         tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port8,           chassisR,      tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl11)
#pragma config(Motor,  port9,           chassisL,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl9)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "SmartMotorLib.c"

/*														MARGINAL VALUES 															 */
/*---------------------------------------------------------------------------*/
int speedL;
int speedR;

int autonomousCount;
bool startingLeft; // A global variable to determine what to do based on the users decision

const char leftButton = 1;
const char centerButton = 2;
const char rightButton = 4;

const int armFullCube =90;
const int armFull = 120;
const int armHoldNone = 25;
const int armHoldStar = 40;
const int armHoldCube = 45;
const int armHold3Star = 50;
const int armHoldCubeandStar = 72;

const int turn45 = 130;
const int turn90 = 280;
const int turn180 = 320;

const int pincherLOpen = 1100;
const int pincherROpen = 1100;
const int pincherLMid = 1550;
const int pincherRMid = 1550;
const int pincherLClose = 2200;
const int pincherRClose = 2200;

int gyroAngle;
/*---------------------------------------------------------------------------*/

/* 												BASIC MOVEMENTS                  									 */
/*---------------------------------------------------------------------------*/
void armDrive(int armspeed)
{
	motor[armL1] = armspeed;
	motor[armR1] = armspeed;
	motor[armL2] = armspeed;
	motor[armR2] = armspeed;
}

void chassisDrive(int chassisR, int chassisL)
{
	motor[chassisR] = chassisR;
	motor[chassisL] = chassisL;
}

void pincherDrive(int pincherspeed)
{
	motor[pincherL] = pincherspeed;
	motor[pincherR] = pincherspeed;
}
/*---------------------------------------------------------------------------*/

/* 												RESET FUNCTIOINS																	 */
/*---------------------------------------------------------------------------*/
void resetChassisEncoders()
{
	SensorValue[encoderR]=0;
	SensorValue[encoderL]=0;
}

void resetArmEncoder()
{
	SensorValue[encoderArm]=0;
}

int pCalc(int target, tSensors sensorName,float pValue)
{
	int error = abs(target - SensorValue[sensorName]);
	int index = (int)error * pValue;
	if(index > 125)//prevent overshot the motor
	{
		index = 125;
	}
	else
	{
		index = index;
	}

	return index;
}

void SmartMotorSetUp()
{
	SmartMotorsInit();
	SmartMotorsAddPowerExtender(armR1,armR2,armL1,armL2);
	SmartMotorLinkMotors(armR1,armR2);
	SmartMotorLinkMotors(armR1,armL1);
	SmartMotorLinkMotors(armR1,armL2);
	SmartMotorsSetEncoderGearing(armR1,5.0);
	SmartMotorCurrentMonitorEnable();
	SmartMotorRun();
}

task openPincher()
{
	while(SensorValue[pincherDegreeL] > pincherLOpen  || SensorValue[pincherDegreeR] > pincherROpen)
	{
		int openIndexL = pCalc(pincherLOpen, pincherDegreeL, 0.7);
		int openIndexR = pCalc(pincherROpen, pincherDegreeR,0.7);

		if(openIndexL < 20 || openIndexR <20)
		{
			break;
		}

		if(SensorValue[pincherDegreeL] > pincherLOpen)
		{
			motor[pincherL] = -openIndexL;
		}

		if(SensorValue[pincherDegreeR] > pincherROpen)
		{
			motor[pincherR] = -openIndexR;
		}
	}
	pincherDrive(0);
}

task closePincher()
{
	int preReadL = 800;
	int preReadR = 800;
	int currentReadL;
	int currentReadR;
	int achievedCountL =0;
	int achievedCountR =0;

	pincherDrive(125);
	wait1Msec(200);
	while(SensorValue[pincherDegreeL] < pincherLClose || SensorValue[pincherDegreeR] < pincherRClose)
	{
		currentReadL = SensorValue[pincherDegreeL];
		currentReadR = SensorValue[pincherDegreeR];

		speedL = abs(currentReadL - preReadL);
		speedR = abs(currentReadR - preReadR);

		if(SensorValue[pincherDegreeL] < pincherLClose)
		{
			if(speedL>0)
			{
				motor[pincherL] =125;
			}
			else
			{
				achievedCountL++;
				motor[pincherL] = 0;
			}
		}
		else
		{
			motor[pincherL] = 0;
		}

		if(SensorValue[pincherDegreeR] < pincherRClose)
		{
			if(speedR>0)
			{
				motor[pincherR] =125;
			}
			else
			{
				achievedCountR++;
				motor[pincherR] = 0;
			}
		}
		else
		{
			motor[pincherR] = 0;
		}

		if(achievedCountL >1 && achievedCountR >1)
		{
			break;
		}
		preReadL = currentReadL;
		preReadR = currentReadR;
	}
	pincherDrive(0);
}


/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/



task main()
{
	SmartMotorSetUp();
	int Ch2Value;
	int Ch3Value;
  while (true)
  {
  	if(abs(vexRT[Ch2])>20)
  	{
  		Ch2Value = vexRT[Ch2];
  	}
  	else
  	{
			Ch2Value = 0;
		}

		if(abs(vexRT[Ch3])
			>20)
  	{
  		Ch3Value = vexRT[Ch3];
  	}
  	else
  	{
			Ch3Value = 0;
		}

		SetMotor(chassisR,vexRT[Ch2]);
		SetMotor(chassisL,vexRT[Ch3]);

		if(vexRT[Btn6U] ==1)
		{
			stopTask(closePincher);
			armDrive(125);
		}

		else if(vexRT[Btn6D]==1)
		{
			armDrive(-90);
		}

		else
		{
			armDrive(0);
		}

		if(vexRT[Btn5U] ==1)
		{
			stopTask(openPincher);
			startTask(closePincher);
		}

		else if(vexRT[Btn5D]==1)
		{
			stopTask(closePincher);
			startTask(openPincher);
		}
		else
		{
			pincherDrive(0);
		}
	}
}
